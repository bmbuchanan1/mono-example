declare class Logger {
    interactive: boolean;
    dry: boolean;
    step: number;
    constructor({ interactive, dry, }?: {
        interactive?: boolean;
        dry?: boolean;
    });
    logger(...args: any[]): void;
    indented(level: number, ...args: any[]): void;
    header(title: string): void;
    installerFrames(): string[];
    gradient(text: string | number): string;
    hero(): void;
    info(...args: any[]): void;
    mainStep(title: string): void;
    subStep(...args: any[]): void;
    subStepFailure(...args: any[]): void;
    rootHeader(): void;
    rootStep(...args: any[]): void;
    workspaceHeader(): void;
    workspaceStep(...args: any[]): void;
    blankLine(): void;
    error(...args: any[]): void;
}

type PackageManager = "npm" | "pnpm" | "yarn";
type PackageManagerDetails = {
    name: PackageManager;
    version?: string;
};
type Project = {
    name: string;
    description?: string;
    packageManager: PackageManager;
    paths: {
        root: string;
        packageJson: string;
        lockfile: string;
        nodeModules: string;
        workspaceConfig?: string;
    };
    workspaceData: {
        globs: Array<string>;
        workspaces: Array<Workspace>;
    };
};
type Workspace = {
    name: string;
    description?: string;
    paths: {
        root: string;
        packageJson: string;
        nodeModules: string;
    };
};
type DetectArgs = {
    workspaceRoot: string;
};
type ReadArgs = {
    workspaceRoot: string;
};
type CreateArgs = {
    project: Project;
    to: PackageManagerDetails;
    logger: Logger;
    options?: Options;
};
type RemoveArgs = {
    project: Project;
    to: PackageManagerDetails;
    logger: Logger;
    options?: Options;
};
type CleanArgs = {
    project: Project;
    logger: Logger;
    options?: Options;
};
type ConvertArgs = {
    project: Project;
    logger: Logger;
    options?: Options;
};
type InstallArgs = {
    project: Project;
    to: PackageManagerDetails;
    logger?: Logger;
    options?: Options;
};
type Options = {
    dry?: boolean;
    skipInstall?: boolean;
    interactive?: boolean;
};
type PackageManagerInstallDetails = {
    name: string;
    template: string;
    command: PackageManager;
    installArgs: string[];
    version: string;
    executable: string;
    semver: string;
    default?: boolean;
};
type ManagerDetect = (args: DetectArgs) => Promise<boolean>;
type ManagerRead = (args: ReadArgs) => Promise<Project>;
type ManagerCreate = (args: CreateArgs) => Promise<void>;
type ManagerRemove = (args: RemoveArgs) => Promise<void>;
type ManagerClean = (args: CleanArgs) => Promise<void>;
type ManagerConvert = (args: ConvertArgs) => Promise<void>;
type ManagerHandler = {
    detect: ManagerDetect;
    read: ManagerRead;
    create: ManagerCreate;
    remove: ManagerRemove;
    clean: ManagerClean;
    convertLock: ManagerConvert;
};

declare function getWorkspaceDetails({ root, }: {
    root: string;
}): Promise<Project>;

declare function getPackageManagerMeta(packageManager: PackageManagerDetails): PackageManagerInstallDetails | undefined;
declare function install(args: InstallArgs): Promise<void>;

type ConvertErrorType = "package_manager-unexpected" | "package_manager-already_in_use" | "package_manager-unable_to_detect" | "package_manager-unsupported_version" | "pnpm-workspace_parse_error" | "package_json-parse_error" | "package_json-missing" | "invalid_directory" | "error_removing_node_modules" | "unknown";
type ConvertErrorOptions = {
    type?: ConvertErrorType;
};
declare class ConvertError extends Error {
    type: ConvertErrorType;
    constructor(message: string, opts?: ConvertErrorOptions);
}

declare const MANAGERS: Record<PackageManager, ManagerHandler>;

declare function convert({ root, to, options, }: {
    root: string;
    to: PackageManager;
    options?: Options;
}): Promise<void>;

export { ConvertError, ConvertErrorType, InstallArgs, MANAGERS, Options, PackageManager, Project, Workspace, convert, getPackageManagerMeta, getWorkspaceDetails, install };
